/dsa-graph-visualiser
//node_modules
//public
//src
///assets
///App.jsx

import { useState, useRef, useEffect } from 'react';
import { motion } from 'framer-motion';

export default function GraphVisualizer() {
  // State management
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [nodeValue, setNodeValue] = useState('');
  const [fromNode, setFromNode] = useState('');
  const [toNode, setToNode] = useState('');
  const [edgeWeight, setEdgeWeight] = useState('');
  const [draggingId, setDraggingId] = useState(null);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [theme, setTheme] = useState('dark');
  const [graphType, setGraphType] = useState('undirected');
  const [traversalType, setTraversalType] = useState('BFS');
  const [startNode, setStartNode] = useState('');
  const [isRunningBFS, setIsRunningBFS] = useState(false);
  const [bfsResult, setBfsResult] = useState(null);
  const [isRunningDFS, setIsRunningDFS] = useState(false);
  const [dfsResult, setDfsResult] = useState(null);
  const [dijkstraStart, setDijkstraStart] = useState('');
  const [dijkstraTarget, setDijkstraTarget] = useState('');
  const [dijkstraResult, setDijkstraResult] = useState(null);
  const [isRunningDijkstra, setIsRunningDijkstra] = useState(false);
  const [isChecked, setIsChecked] = useState(false);
  const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, nodeId: null, edgeId: null });
  const [algorithmProgress, setAlgorithmProgress] = useState(0);
  const [algorithmPaused, setAlgorithmPaused] = useState(false);
  const [algorithmSpeed, setAlgorithmSpeed] = useState(800);
  const [algorithmSteps, setAlgorithmSteps] = useState([]);
  const [currentAlgorithm, setCurrentAlgorithm] = useState(null);
  const [heuristicType, setHeuristicType] = useState('euclidean');
  const [hoveredElement, setHoveredElement] = useState(null);
  const [isRunningPrim, setIsRunningPrim] = useState(false);
  const [primResult, setPrimResult] = useState(null);
  const [isRunningAStar, setIsRunningAStar] = useState(false);
  const [aStarResult, setAStarResult] = useState(null);
  const [savedGraphs, setSavedGraphs] = useState([]);
  const [tutorialStep, setTutorialStep] = useState(0);
  const [showTutorial, setShowTutorial] = useState(true);
  
  const canvasRef = useRef(null);
  const containerRef = useRef(null);
  const animationRef = useRef(null);

  const handleCheckboxChange = () => {
    setIsChecked(!isChecked);
  };

  useEffect(() => {
    if(isChecked) {
      setTraversalType('DFS');
    } else {
      setTraversalType('BFS');
    }
  }, [isChecked]);

  // Initialize saved graphs from localStorage
  useEffect(() => {
    const saved = localStorage.getItem('savedGraphs');
    if (saved) {
      setSavedGraphs(JSON.parse(saved));
    }
  }, []);

  // Reset graph when graph type changes
  useEffect(() => {
    setNodes([]);
    setEdges([]);
    resetAlgorithm();
  }, [graphType]);

  // Reset all algorithm states
  const resetAlgorithm = () => {
    setIsRunningBFS(false);
    setIsRunningDFS(false);
    setIsRunningDijkstra(false);
    setIsRunningPrim(false);
    setIsRunningAStar(false);
    setBfsResult(null);
    setDfsResult(null);
    setDijkstraResult(null);
    setPrimResult(null);
    setAStarResult(null);
    setAlgorithmProgress(0);
    if (animationRef.current) {
      clearInterval(animationRef.current);
      animationRef.current = null;
    }
  };

  // Toggle theme
  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };

  // Add new node
  const addNode = (x, y) => {
    if (nodeValue.trim()) {
      const existingNode = nodes.find((node) => node.value === nodeValue);
      if (existingNode) {
        alert('A node with this value already exists. Please choose a different value.');
        return;
      }

      const id = Date.now();
      const rect = containerRef.current.getBoundingClientRect();
      const posX = x || rect.width / 2 + Math.random() * 100 - 50;
      const posY = y || rect.height / 2 + Math.random() * 100 - 50;

      setNodes([...nodes, { id, value: nodeValue, x: posX, y: posY }]);
      setNodeValue('');
    }
  };

  // Add edge between nodes
  const addEdge = (startId, endId, weight) => {
    const start = startId || parseInt(fromNode);
    const end = endId || parseInt(toNode);
    const weightNum = weight || parseFloat(edgeWeight);
    
    if (!isNaN(start) && !isNaN(end) && !isNaN(weightNum)) {
      // Prevent self-loops
      if (start === end) {
        alert('Cannot create an edge from a node to itself!');
        return;
      }
      
      // Check if edge already exists
      const edgeExists = edges.some(edge => 
        (edge.start === start && edge.end === end) || 
        (!edge.directed && edge.start === end && edge.end === start)
      );
      
      if (edgeExists) {
        alert('An edge between these nodes already exists!');
        return;
      }
      
      setEdges([
        ...edges,
        {
          id: Date.now(),
          start: start,
          end: end,
          weight: weightNum,
          directed: graphType === 'directed',
        },
      ]);
      setFromNode('');
      setToNode('');
      setEdgeWeight('');
    }
  };

  // Handle drag start
  const handleMouseDown = (e) => {
    e.preventDefault();
    
    if (e.button !== 0) return;

    const rect = containerRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const nodeUnderCursor = nodes.find((node) => {
      const dx = mouseX - node.x;
      const dy = mouseY - node.y;
      return Math.hypot(dx, dy) <= 30;
    });

    setDraggingId(nodeUnderCursor ? nodeUnderCursor.id : null);
    
    if (nodeUnderCursor) {
      const offsetX = mouseX - nodeUnderCursor.x;
      const offsetY = mouseY - nodeUnderCursor.y;
      setOffset({ x: offsetX, y: offsetY });
    }
  };

  // Handle mouse move for dragging
  const handleMouseMove = (e) => {
    if (draggingId !== null) {
      const rect = containerRef.current.getBoundingClientRect();
      let newX = e.clientX - rect.left - offset.x;
      let newY = e.clientY - rect.top - offset.y;

      newX = Math.max(40, Math.min(rect.width - 40, newX));
      newY = Math.max(40, Math.min(rect.height - 40, newY));

      setNodes(nodes.map((node) =>
        node.id === draggingId ? { ...node, x: newX, y: newY } : node
      ));
    }
  };

  // Handle mouse over elements
  const handleMouseOver = (e) => {
    const rect = containerRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Check if hovering over a node
    const nodeUnderCursor = nodes.find((node) => {
      const dx = mouseX - node.x;
      const dy = mouseY - node.y;
      return Math.hypot(dx, dy) <= 30;
    });

    if (nodeUnderCursor) {
      setHoveredElement({ type: 'node', id: nodeUnderCursor.id });
      return;
    }

    // Check if hovering over an edge
    const edgeUnderCursor = edges.find((edge) => {
      const startNode = nodes.find((n) => n.id === edge.start);
      const endNode = nodes.find((n) => n.id === edge.end);
      if (!startNode || !endNode) return false;

      const dx = endNode.x - startNode.x;
      const dy = endNode.y - startNode.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist === 0) return false;

      const t = ((mouseX - startNode.x) * dx + (mouseY - startNode.y) * dy) / (dist * dist);
      const nearestX = startNode.x + t * dx;
      const nearestY = startNode.y + t * dy;
      return Math.hypot(mouseX - nearestX, mouseY - nearestY) < 10;
    });

    if (edgeUnderCursor) {
      setHoveredElement({ type: 'edge', id: edgeUnderCursor.id });
      return;
    }

    setHoveredElement(null);
  };

  // Draw edges and nodes on canvas
  const drawGraph = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const container = containerRef.current;
    if (!container) return;

    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    ctx.clearRect(0, 0, rect.width, rect.height);

    // Background gradient
    const gradient = ctx.createLinearGradient(0, 0, rect.width, rect.height);
    gradient.addColorStop(0, theme === 'light' ? '#e0e7ff' : '#1e293b');
    gradient.addColorStop(1, theme === 'light' ? '#dbeafe' : '#0f172a');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, rect.width, rect.height);

    // Draw edges and arrowheads first
    edges.forEach((edge) => {
      const startNode = nodes.find((n) => n.id === edge.start);
      const endNode = nodes.find((n) => n.id === edge.end);
      if (startNode && endNode) {
        const startX = startNode.x;
        const startY = startNode.y;
        const endX = endNode.x;
        const endY = endNode.y;

        // Highlight hovered edge
        const isHovered = hoveredElement?.type === 'edge' && hoveredElement.id === edge.id;
        
        // Draw edge line
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = isHovered ? '#f59e0b' : (theme === "light" ? '#4B5563' : '#D1D5DB');
        ctx.lineWidth = isHovered ? 4 : 2;
        ctx.stroke();

        // Edge Weight Text
        ctx.fillStyle = isHovered ? '#f59e0b' : (theme === "light" ? '#1F2937' : '#D1D5DB');
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(
          edge.weight.toFixed(1),
          (startX + endX) / 2,
          (startY + endY) / 2 - 15
        );

        // Directed Arrowhead
        if (edge.directed) {
          const angle = Math.atan2(endY - startY, endX - startX);
          const arrowLength = 15;
          const arrowOffset = 30; // Adjust to not overlap node
          
          ctx.beginPath();
          ctx.moveTo(
            endX - arrowOffset * Math.cos(angle),
            endY - arrowOffset * Math.sin(angle)
          );
          ctx.lineTo(
            endX - arrowOffset * Math.cos(angle) - arrowLength * Math.cos(angle - Math.PI / 6),
            endY - arrowOffset * Math.sin(angle) - arrowLength * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            endX - arrowOffset * Math.cos(angle) - arrowLength * Math.cos(angle + Math.PI / 6),
            endY - arrowOffset * Math.sin(angle) - arrowLength * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fillStyle = isHovered ? '#f59e0b' : (theme === "light" ? '#1F2937' : '#D1D5DB');
          ctx.fill();
        }
      }
    });

    // Draw nodes last to ensure they appear on top
    nodes.forEach((node) => {
      let isVisited = false;
      let isCurrent = false;
      let isInPath = false;
      let isMSTNode = false;
      let isAStarPath = false;

      if (traversalType === 'BFS' && bfsResult) {
        isVisited = bfsResult.visitedOrder?.includes(node.id);
        isCurrent = bfsResult.currentStep === node.id;
      } else if (traversalType === 'DFS' && dfsResult) {
        isVisited = dfsResult.visitedOrder?.includes(node.id);
        isCurrent = dfsResult.currentStep === node.id;
      } else if (dijkstraResult) {
        isCurrent = dijkstraResult.currentStep === node.id;
        isInPath = dijkstraResult.path.includes(node.id);
        isVisited = dijkstraResult.visitedOrder.includes(node.id);
      } else if (primResult) {
        isMSTNode = primResult.mstNodes.includes(node.id);
      } else if (aStarResult) {
        isInPath = aStarResult.path.includes(node.id);
        isVisited = aStarResult.visitedOrder.includes(node.id);
      }

      // Highlight hovered node
      const isHovered = hoveredElement?.type === 'node' && hoveredElement.id === node.id;
      
      ctx.beginPath();
      ctx.arc(node.x, node.y, 30, 0, Math.PI * 2);

      const gradient = ctx.createRadialGradient(node.x, node.y, 5, node.x, node.y, 30);

      if (isRunningDijkstra || isRunningBFS || isRunningDFS || isRunningPrim || isRunningAStar) {
        if (node.id === dijkstraStart || node.id === aStarResult?.start) {
          gradient.addColorStop(0, '#10B981'); // Emerald for source
          gradient.addColorStop(1, '#059669');
        } else if (node.id === dijkstraTarget || node.id === aStarResult?.target) {
          gradient.addColorStop(0, '#EF4444'); // Red for target
          gradient.addColorStop(1, '#DC2626');
        } else if (isInPath || isAStarPath) {
          gradient.addColorStop(0, '#F97316'); // Orange for path nodes
          gradient.addColorStop(1, '#EA580C');
        } else if (isCurrent) {
          gradient.addColorStop(0, '#EC4899'); // Hot pink for current step
          gradient.addColorStop(1, '#DB2777');
        } else if (isVisited) {
          gradient.addColorStop(0, '#60A5FA'); // Sky blue for visited
          gradient.addColorStop(1, '#3B82F6');
        } else if (isMSTNode) {
          gradient.addColorStop(0, '#8B5CF6'); // Purple for MST nodes
          gradient.addColorStop(1, '#7C3AED');
        } else {
          gradient.addColorStop(0, '#3B82F6'); // Blue for unvisited
          gradient.addColorStop(1, '#2563EB');
        }
      } else {
        gradient.addColorStop(0, isHovered ? '#60A5FA' : '#3B82F6');
        gradient.addColorStop(1, isHovered ? '#3B82F6' : '#2563EB');
      }

      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.strokeStyle = isHovered ? '#f59e0b' : '#1E40AF';
      ctx.lineWidth = isHovered ? 3.5 : 2.5;
      ctx.stroke();

      ctx.fillStyle = '#FFFFFF';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.value, node.x, node.y);
    });
  };

  // Save graph to localStorage
  const saveGraph = () => {
    const graphName = prompt('Enter a name for this graph:');
    if (graphName) {
      const graphData = {
        name: graphName,
        nodes,
        edges,
        graphType,
        createdAt: new Date().toISOString()
      };
      
      const updatedGraphs = [...savedGraphs, graphData];
      setSavedGraphs(updatedGraphs);
      localStorage.setItem('savedGraphs', JSON.stringify(updatedGraphs));
      alert(`Graph "${graphName}" saved successfully!`);
    }
  };

  // Load graph from localStorage
  const loadGraph = (graphData) => {
    if (window.confirm('Load this graph? Current graph will be replaced.')) {
      setNodes(graphData.nodes);
      setEdges(graphData.edges);
      setGraphType(graphData.graphType);
      resetAlgorithm();
    }
  };

  // Generate random graph
  const generateRandomGraph = () => {
    resetAlgorithm();
    const newNodeCount = Math.floor(Math.random() * 6) + 5; // 5-10 nodes
    const newNodes = [];
    const newEdges = [];
    const rect = containerRef.current.getBoundingClientRect();
    
    // Create nodes
    for (let i = 1; i <= newNodeCount; i++) {
      const id = Date.now() + i;
      const x = 100 + Math.random() * (rect.width - 200);
      const y = 100 + Math.random() * (rect.height - 200);
      newNodes.push({ id, value: `Node ${i}`, x, y });
    }
    
    // Create edges (30-50% of possible connections)
    const possibleEdges = [];
    for (let i = 0; i < newNodes.length; i++) {
      for (let j = i + 1; j < newNodes.length; j++) {
        possibleEdges.push([newNodes[i].id, newNodes[j].id]);
      }
    }
    
    const edgeCount = Math.floor(possibleEdges.length * (0.3 + Math.random() * 0.2));
    for (let i = 0; i < edgeCount; i++) {
      if (possibleEdges.length === 0) break;
      
      const randomIndex = Math.floor(Math.random() * possibleEdges.length);
      const [start, end] = possibleEdges.splice(randomIndex, 1)[0];
      const weight = (1 + Math.random() * 9).toFixed(1); // 1-10
      
      newEdges.push({
        id: Date.now() + i,
        start,
        end,
        weight: parseFloat(weight),
        directed: graphType === 'directed'
      });
    }
    
    setNodes(newNodes);
    setEdges(newEdges);
  };

  // Edit node value
  const editNode = (nodeId) => {
    const node = nodes.find(n => n.id === nodeId);
    const newValue = prompt('Enter new value for node:', node.value);
    if (newValue !== null) {
      setNodes(nodes.map(n => n.id === nodeId ? { ...n, value: newValue } : n));
    }
  };

  // Delete node
  const deleteNode = (nodeId) => {
    if (window.confirm('Delete this node and all connected edges?')) {
      setNodes(nodes.filter(n => n.id !== nodeId));
      setEdges(edges.filter(e => e.start !== nodeId && e.end !== nodeId));
    }
  };

  // Edit edge weight
  const editEdge = (edgeId) => {
    const edge = edges.find(e => e.id === edgeId);
    const newWeight = prompt('Enter new weight for edge:', edge.weight);
    if (newWeight !== null && !isNaN(parseFloat(newWeight))) {
      setEdges(edges.map(e => 
        e.id === edgeId ? { ...e, weight: parseFloat(newWeight) } : e
      ));
    }
  };

  // Delete edge
  const deleteEdge = (edgeId) => {
    if (window.confirm('Delete this edge?')) {
      setEdges(edges.filter(e => e.id !== edgeId));
    }
  };

  // Run BFS algorithm
  const runBFS = () => {
    if (!startNode || nodes.length === 0) return;
    
    const adjacencyList = buildAdjacencyList();
    const visited = new Set([startNode]);
    const queue = [startNode];
    const visitedOrder = [startNode];
    const steps = [{ currentStep: startNode, visitedOrder: [...visitedOrder] }];
    
    while (queue.length > 0) {
      const current = queue.shift();
      
      const neighbors = adjacencyList[current] || [];
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor.node)) {
          visited.add(neighbor.node);
          visitedOrder.push(neighbor.node);
          queue.push(neighbor.node);
          steps.push({ currentStep: neighbor.node, visitedOrder: [...visitedOrder] });
        }
      }
    }
    
    setBfsResult({
      visitedOrder,
      currentStep: null,
      stepIndex: 0,
      steps
    });
    
    setAlgorithmSteps(steps);
    setCurrentAlgorithm('BFS');
    setAlgorithmProgress(0);
    animateAlgorithm(steps, 'BFS');
  };

  // Run DFS algorithm
  const runDFS = () => {
    if (!startNode || nodes.length === 0) return;
    
    const adjacencyList = buildAdjacencyList();
    const visited = new Set();
    const visitedOrder = [];
    const steps = [];
    
    const dfs = (node) => {
      visited.add(node);
      visitedOrder.push(node);
      steps.push({ currentStep: node, visitedOrder: [...visitedOrder] });
      
      const neighbors = adjacencyList[node] || [];
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor.node)) {
          dfs(neighbor.node);
        }
      }
    };
    
    dfs(startNode);
    
    setDfsResult({
      visitedOrder,
      currentStep: null,
      stepIndex: 0,
      steps
    });
    
    setAlgorithmSteps(steps);
    setCurrentAlgorithm('DFS');
    setAlgorithmProgress(0);
    animateAlgorithm(steps, 'DFS');
  };

  // Run Dijkstra's algorithm
  const runDijkstra = () => {
    if (!dijkstraStart || !dijkstraTarget || nodes.length === 0) return;
    
    const adjacencyList = buildAdjacencyList();
    const distances = {};
    const previous = {};
    const visited = new Set();
    const steps = [];
    
    // Initialize distances
    nodes.forEach(node => {
      distances[node.id] = Infinity;
    });
    distances[dijkstraStart] = 0;
    
    // Priority queue (using array for simplicity)
    const unvisited = [...nodes.map(node => node.id)];
    
    while (unvisited.length > 0) {
      // Find node with smallest distance
      unvisited.sort((a, b) => distances[a] - distances[b]);
      const closest = unvisited.shift();
      
      // If closest is Infinity, break early
      if (distances[closest] === Infinity) break;
      
      visited.add(closest);
      steps.push({
        currentStep: closest,
        visitedOrder: Array.from(visited),
        distances: { ...distances }
      });
      
      // If we reached the target, break early
      if (closest === dijkstraTarget) break;
      
      // Process neighbors
      const neighbors = adjacencyList[closest] || [];
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor.node)) {
          const alt = distances[closest] + neighbor.weight;
          if (alt < distances[neighbor.node]) {
            distances[neighbor.node] = alt;
            previous[neighbor.node] = closest;
          }
        }
      }
    }
    
    // Reconstruct path
    const path = [];
    let current = dijkstraTarget;
    while (current !== undefined) {
      path.unshift(current);
      current = previous[current];
    }
    
    setDijkstraResult({
      path,
      distances,
      visitedOrder: Array.from(visited),
      currentStep: null,
      stepIndex: 0,
      steps
    });
    
    setAlgorithmSteps(steps);
    setCurrentAlgorithm('Dijkstra');
    setAlgorithmProgress(0);
    animateAlgorithm(steps, 'Dijkstra');
  };

  // Run Prim's MST algorithm
  const runPrimMST = () => {
    if (nodes.length === 0) return;
    
    const startId = nodes[0].id;
    const adjacencyList = buildAdjacencyList();
    const visited = new Set([startId]);
    const mstEdges = [];
    const steps = [];
    
    while (visited.size < nodes.length) {
      let minEdge = null;
      
      for (const nodeId of visited) {
        const neighbors = adjacencyList[nodeId] || [];
        for (const neighbor of neighbors) {
          if (!visited.has(neighbor.node)) {
            if (!minEdge || neighbor.weight < minEdge.weight) {
              minEdge = {
                from: nodeId,
                to: neighbor.node,
                weight: neighbor.weight
              };
            }
          }
        }
      }
      
      if (minEdge) {
        visited.add(minEdge.to);
        mstEdges.push(minEdge);
        steps.push({
          currentStep: minEdge.to,
          visitedSoFar: [...visited],
          mstEdges: [...mstEdges],
          timestamp: Date.now()
        });
      }
    }
    
    setPrimResult({
      mstEdges,
      mstNodes: Array.from(visited),
      currentStep: null,
      stepIndex: 0,
      steps
    });
    
    setAlgorithmSteps(steps);
    setCurrentAlgorithm('Prim');
    setAlgorithmProgress(0);
    animateAlgorithm(steps, 'Prim');
  };

  // Run A* Search algorithm
  const runAStar = () => {
    if (!dijkstraStart || !dijkstraTarget || nodes.length === 0) return;
    
    const adjacencyList = buildAdjacencyList();
    const openSet = new Set([dijkstraStart]);
    const cameFrom = {};
    const gScore = {};
    const fScore = {};
    
    nodes.forEach(node => {
      gScore[node.id] = Infinity;
      fScore[node.id] = Infinity;
    });
    
    gScore[dijkstraStart] = 0;
    
    // Heuristic function (Euclidean distance)
    const heuristic = (aId, bId) => {
      const nodeA = nodes.find(n => n.id === aId);
      const nodeB = nodes.find(n => n.id === bId);
      if (!nodeA || !nodeB) return Infinity;
      
      if (heuristicType === 'manhattan') {
        return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);
      }
      return Math.sqrt(Math.pow(nodeA.x - nodeB.x, 2) + Math.pow(nodeA.y - nodeB.y, 2));
    };
    
    fScore[dijkstraStart] = heuristic(dijkstraStart, dijkstraTarget);
    
    const steps = [];
    let stepCount = 0;
    
    while (openSet.size > 0) {
      let current = null;
      let lowestFScore = Infinity;
      
      for (const nodeId of openSet) {
        if (fScore[nodeId] < lowestFScore) {
          lowestFScore = fScore[nodeId];
          current = nodeId;
        }
      }
      
      if (current === dijkstraTarget) {
        // Reconstruct path
        const path = [];
        let temp = current;
        while (temp !== undefined) {
          path.unshift(temp);
          temp = cameFrom[temp];
        }
        
        setAStarResult({
          path,
          visitedOrder: steps.map(s => s.current),
          currentStep: null,
          stepIndex: 0,
          start: dijkstraStart,
          target: dijkstraTarget
        });
        
        setAlgorithmSteps(steps);
        setCurrentAlgorithm('AStar');
        setAlgorithmProgress(0);
        animateAlgorithm(steps, 'AStar');
        return;
      }
      
      openSet.delete(current);
      steps.push({
        current,
        visitedOrder: [...steps.map(s => s.current), current],
        timestamp: Date.now(),
        stepNumber: stepCount++
      });
      
      const neighbors = adjacencyList[current] || [];
      for (const neighbor of neighbors) {
        const tentativeGScore = gScore[current] + neighbor.weight;
        
        if (tentativeGScore < gScore[neighbor.node]) {
          cameFrom[neighbor.node] = current;
          gScore[neighbor.node] = tentativeGScore;
          fScore[neighbor.node] = tentativeGScore + heuristic(neighbor.node, dijkstraTarget);
          
          if (!openSet.has(neighbor.node)) {
            openSet.add(neighbor.node);
          }
        }
      }
    }
    
    // No path found
    setAStarResult({
      path: [],
      visitedOrder: steps.map(s => s.current),
      currentStep: null,
      stepIndex: 0,
      start: dijkstraStart,
      target: dijkstraTarget
    });
    
    setAlgorithmSteps(steps);
    setCurrentAlgorithm('AStar');
    setAlgorithmProgress(0);
    animateAlgorithm(steps, 'AStar');
  };

  // Animate algorithm execution
  const animateAlgorithm = (steps, algorithm) => {
    if (animationRef.current) {
      clearInterval(animationRef.current);
    }
    
    if (algorithm === 'BFS') setIsRunningBFS(true);
    if (algorithm === 'DFS') setIsRunningDFS(true);
    if (algorithm === 'Dijkstra') setIsRunningDijkstra(true);
    if (algorithm === 'Prim') setIsRunningPrim(true);
    if (algorithm === 'AStar') setIsRunningAStar(true);
    
    let i = 0;
    animationRef.current = setInterval(() => {
      if (algorithmPaused) return;
      
      if (i >= steps.length) {
        clearInterval(animationRef.current);
        animationRef.current = null;
        if (algorithm === 'BFS') setIsRunningBFS(false);
        if (algorithm === 'DFS') setIsRunningDFS(false);
        if (algorithm === 'Dijkstra') setIsRunningDijkstra(false);
        if (algorithm === 'Prim') setIsRunningPrim(false);
        if (algorithm === 'AStar') setIsRunningAStar(false);
        setAlgorithmPaused(false);
        return;
      }
      
      const stepObj = steps[i];
      
      if (algorithm === 'BFS') {
        setBfsResult(prev => ({
          ...prev,
          currentStep: stepObj.currentStep,
          stepIndex: i,
        }));
      } else if (algorithm === 'DFS') {
        setDfsResult(prev => ({
          ...prev,
          currentStep: stepObj.currentStep || null,
          stepIndex: i,
        }));
      } else if (algorithm === 'Dijkstra') {
        setDijkstraResult(prev => ({
          ...prev,
          currentStep: stepObj.currentStep,
          stepIndex: i,
        }));
      } else if (algorithm === 'Prim') {
        setPrimResult(prev => ({
          ...prev,
          currentStep: stepObj.currentStep,
          stepIndex: i,
          mstEdges: stepObj.mstEdges,
          mstNodes: stepObj.visitedSoFar
        }));
      } else if (algorithm === 'AStar') {
        setAStarResult(prev => ({
          ...prev,
          currentStep: stepObj.current,
          stepIndex: i,
          visitedOrder: stepObj.visitedOrder
        }));
      }
      
      setAlgorithmProgress(Math.round((i / steps.length) * 100));
      i++;
    }, algorithmSpeed);
  };

  // Build adjacency list
  const buildAdjacencyList = () => {
    const adj = {};
    nodes.forEach((node) => (adj[node.id] = []));
    edges.forEach((edge) => {
      adj[edge.start].push({ node: edge.end, weight: edge.weight });
      if (graphType === 'undirected') {
        adj[edge.end].push({ node: edge.start, weight: edge.weight });
      }
    });
    return adj;
  };

  // Tutorial steps
  const tutorialSteps = [
    "Welcome to Graph Algorithm Visualizer! Let's get started.",
    "First, add some nodes using the 'Add Node' section. Each node needs a unique name.",
    "Now connect your nodes by selecting 'From' and 'To' nodes and adding an edge weight.",
    "You can drag nodes around to organize your graph visually.",
    "Try running different algorithms like BFS, DFS, Dijkstra, Prim's MST, or A* Search!",
    "Right-click anywhere on the canvas for additional options.",
    "Save your graph to come back to it later using the 'Save Graph' button.",
    "Explore different graph types (directed/undirected) and themes using the top controls."
  ];

  // Close context menu
  const closeContextMenu = () => {
    setContextMenu({ visible: false, x: 0, y: 0, nodeId: null, edgeId: null });
  };

  // Handle context menu
  const handleContextMenu = (e) => {
    e.preventDefault();
    
    const rect = containerRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const nodeUnderCursor = nodes.find((node) => {
      const dx = mouseX - node.x;
      const dy = mouseY - node.y;
      return Math.hypot(dx, dy) <= 30;
    });

    let edgeUnderCursor = null;
    if (!nodeUnderCursor) {
      edgeUnderCursor = edges.find((edge) => {
        const startNode = nodes.find((n) => n.id === edge.start);
        const endNode = nodes.find((n) => n.id === edge.end);
        if (!startNode || !endNode) return false;

        const dx = endNode.x - startNode.x;
        const dy = endNode.y - startNode.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist === 0) return false;

        const t = ((mouseX - startNode.x) * dx + (mouseY - startNode.y) * dy) / (dist * dist);
        const nearestX = startNode.x + t * dx;
        const nearestY = startNode.y + t * dy;
        return Math.hypot(mouseX - nearestX, mouseY - nearestY) < 10;
      });
    }

    setContextMenu({
      visible: true,
      x: e.clientX,
      y: e.clientY,
      nodeId: nodeUnderCursor ? nodeUnderCursor.id : null,
      edgeId: edgeUnderCursor ? edgeUnderCursor.id : null
    });
  };

  // Handle mouse up
  const handleMouseUp = () => {
    setDraggingId(null);
  };

  // Handle window resize
  useEffect(() => {
    const handleResize = () => {
      drawGraph();
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [nodes, edges]);

  // Redraw graph when needed
  useEffect(() => {
    drawGraph();
  }, [nodes, edges, draggingId, theme, graphType, bfsResult, dfsResult, traversalType, dijkstraResult, primResult, aStarResult, hoveredElement]);

  // Handle mouse events
  useEffect(() => {
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [draggingId, offset]);

  // Render the component
  return (
    <div className={`min-h-screen transition duration-300 ${theme === 'light' ? 'bg-gradient-to-br from-blue-50 to-indigo-50' : 'bg-gradient-to-br from-gray-900 to-indigo-900'}`}>
      {/* Header */}
      <header className="flex flex-col md:flex-row justify-between items-center px-6 py-4 gap-4">
        <div className="flex items-center gap-3">
          <motion.div 
            className="bg-gradient-to-r from-indigo-600 to-blue-600 p-3 rounded-xl"
            animate={{ rotate: 360 }}
            transition={{ duration: 8, repeat: Infinity, ease: "linear" }}
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          </motion.div>
          <h1 className={`text-3xl md:text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-indigo-600 to-blue-600`}>
            Graph Algorithm Visualizer
          </h1>
        </div>
        <div className="flex flex-wrap justify-center gap-3">
          <div className="flex gap-2 bg-gray-200 dark:bg-gray-800 rounded-full px-2 py-1">
            <button
              onClick={() => setGraphType('directed')}
              className={`px-4 py-2 rounded-full text-sm font-semibold ${
                graphType === 'directed'
                  ? 'bg-gradient-to-r from-indigo-600 to-blue-600 text-white'
                  : theme === 'light'
                  ? 'bg-white text-gray-800'
                  : 'bg-gray-700 text-gray-200'
              }`}
            >
              Directed
            </button>
            <button
              onClick={() => setGraphType('undirected')}
              className={`px-4 py-2 rounded-full text-sm font-semibold ${
                graphType === 'undirected'
                  ? 'bg-gradient-to-r from-indigo-600 to-blue-600 text-white'
                  : theme === 'light'
                  ? 'bg-white text-gray-800'
                  : 'bg-gray-700 text-gray-200'
              }`}
            >
              Undirected
            </button>
          </div>
          <button
            onClick={toggleTheme}
            className={`px-4 py-2 rounded-full text-sm font-semibold flex items-center gap-2 ${
              theme === 'light' ? 'bg-gray-200 text-gray-800' : 'bg-gray-700 text-gray-200'
            }`}
          >
            {theme === 'light' ? 'üåô Dark Mode' : '‚òÄÔ∏è Light Mode'}
          </button>
        </div>
      </header>

      {/* Tutorial Overlay */}
      {showTutorial && (
        <motion.div 
          className="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          <motion.div 
            className="bg-white dark:bg-gray-800 rounded-2xl p-6 max-w-md w-full"
            initial={{ scale: 0.9 }}
            animate={{ scale: 1 }}
          >
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-bold">Interactive Tutorial</h2>
              <button 
                onClick={() => setShowTutorial(false)}
                className="text-gray-500 hover:text-gray-700"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            
            <p className="mb-6 text-gray-700 dark:text-gray-300">
              {tutorialSteps[tutorialStep]}
            </p>
            
            <div className="flex justify-between">
              <button 
                onClick={() => setTutorialStep(Math.max(0, tutorialStep - 1))}
                disabled={tutorialStep === 0}
                className="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg disabled:opacity-50"
              >
                Previous
              </button>
              
              {tutorialStep < tutorialSteps.length - 1 ? (
                <button 
                  onClick={() => setTutorialStep(tutorialStep + 1)}
                  className="px-4 py-2 bg-gradient-to-r from-indigo-600 to-blue-600 text-white rounded-lg"
                >
                  Next
                </button>
              ) : (
                <button 
                  onClick={() => setShowTutorial(false)}
                  className="px-4 py-2 bg-gradient-to-r from-green-600 to-emerald-600 text-white rounded-lg"
                >
                  Start Exploring
                </button>
              )}
            </div>
          </motion.div>
        </motion.div>
      )}

      {/* Main Content */}
      <div className="flex flex-col lg:flex-row px-4 gap-6">
        {/* Sidebar */}
        <div className="w-full lg:w-1/4 space-y-6">
          {/* Global Actions */}
          <div className={`p-5 rounded-2xl shadow-lg ${theme === 'light' ? 'bg-white' : 'bg-gray-800'}`}>
            <h2 className="text-lg font-bold mb-4">Graph Actions</h2>
            <div className="grid grid-cols-2 gap-3">
              <button
                onClick={() => {
                  if (window.confirm('Clear the entire graph?')) {
                    setNodes([]);
                    setEdges([]);
                    resetAlgorithm();
                  }
                }}
                className="px-4 py-2 bg-gradient-to-r from-red-600 to-orange-600 text-white rounded-lg hover:opacity-90 transition"
              >
                Clear Graph
              </button>
              <button
                onClick={generateRandomGraph}
                className="px-4 py-2 bg-gradient-to-r from-purple-600 to-indigo-600 text-white rounded-lg hover:opacity-90 transition"
              >
                Random Graph
              </button>
              <button
                onClick={saveGraph}
                className="px-4 py-2 bg-gradient-to-r from-green-600 to-emerald-600 text-white rounded-lg hover:opacity-90 transition"
              >
                Save Graph
              </button>
              <button
                onClick={() => setShowTutorial(true)}
                className="px-4 py-2 bg-gradient-to-r from-yellow-600 to-amber-600 text-white rounded-lg hover:opacity-90 transition"
              >
                Show Tutorial
              </button>
            </div>
          </div>

          {/* Node Input */}
          <motion.div 
            className={`p-5 rounded-2xl shadow-lg ${theme === 'light' ? 'bg-white' : 'bg-gray-800'}`}
            whileHover={{ y: -5 }}
          >
            <label className="text-center block text-sm font-medium mb-2">Add New Node</label>
            <div className="flex gap-2">
              <input
                type="text"
                value={nodeValue}
                onChange={(e) => setNodeValue(e.target.value)}
                placeholder="Node Value"
                className={`flex-1 border rounded-xl px-4 py-3 focus:outline-none focus:ring-2 ${
                  theme === 'light'
                    ? 'border-gray-300 focus:ring-indigo-400'
                    : 'border-gray-600 bg-gray-700 focus:ring-indigo-500'
                }`}
              />
              <button
                onClick={() => addNode()}
                className="bg-gradient-to-r from-indigo-600 to-blue-600 text-white px-4 py-2 rounded-xl hover:opacity-90 transition flex items-center"
              >
                Add
              </button>
            </div>
          </motion.div>

          {/* Edge Input */}
          <motion.div 
            className={`p-5 rounded-2xl shadow-lg ${theme === 'light' ? 'bg-white' : 'bg-gray-800'}`}
            whileHover={{ y: -5 }}
          >
            <label className="text-center block text-sm font-medium mb-2">Add Edge With Weight</label>
            <div className="grid grid-cols-3 gap-2 mb-3">
              <select
                value={fromNode}
                onChange={(e) => setFromNode(parseInt(e.target.value))}
                className={`rounded-xl px-2 py-3 text-sm ${
                  theme === 'light'
                    ? 'border border-gray-300'
                    : 'border border-gray-600 bg-gray-700'
                }`}
              >
                <option value="">From</option>
                {nodes.map((node) => (
                  <option key={node.id} value={node.id}>
                    {node.value}
                  </option>
                ))}
              </select>
              <select
                value={toNode}
                onChange={(e) => setToNode(parseInt(e.target.value))}
                className={`rounded-xl px-2 py-3 text-sm ${
                  theme === 'light'
                    ? 'border border-gray-300'
                    : 'border border-gray-600 bg-gray-700'
                }`}
              >
                <option value="">To</option>
                {nodes.map((node) => (
                  <option key={node.id} value={node.id}>
                    {node.value}
                  </option>
                ))}
              </select>
              <input
                type="number"
                step="0.1"
                value={edgeWeight}
                onChange={(e) => setEdgeWeight(e.target.value)}
                placeholder="Weight"
                className={`rounded-xl px-2 py-3 text-sm ${
                  theme === 'light'
                    ? 'border border-gray-300'
                    : 'border border-gray-600 bg-gray-700'
                }`}
              />
            </div>
            <button
              onClick={() => addEdge()}
              className="w-full bg-gradient-to-r from-indigo-600 to-blue-600 text-white px-4 py-3 rounded-xl hover:opacity-90 transition"
            >
              Add Edge
            </button>
          </motion.div>

          {/* Algorithm Selection */}
          <div className={`p-5 rounded-2xl shadow-lg ${theme === 'light' ? 'bg-white' : 'bg-gray-800'}`}>
            <h2 className="text-lg font-bold mb-4">Algorithms</h2>
            
            {/* Traversal Mode Handler */}
            <div className="mb-6">
              <div className="flex justify-between items-center mb-4">
                <span className="text-sm">BFS</span>
                <label className='flex cursor-pointer select-none items-center'>
                  <div className='relative'>
                    <input
                      type="checkbox"
                      checked={isChecked}
                      onChange={handleCheckboxChange}
                      className="sr-only peer"
                    />
                    <div
                      className={`h-8 w-14 rounded-full transition-colors duration-300 ${
                        isChecked ? 'bg-gradient-to-r from-indigo-600 to-blue-600' : 'bg-gray-300 dark:bg-gray-700'
                      }`}
                    />
                    <div
                      className={`absolute left-1 top-1 h-6 w-6 rounded-full bg-white shadow-md
                                  transform transition-transform duration-300 ease-in-out
                                  ${isChecked ? 'translate-x-6' : ''}`}
                    />
                  </div>
                </label>
                <span className="text-sm">DFS</span>
              </div>

              <div className="mb-3">
                <select
                  value={startNode}
                  onChange={(e) => setStartNode(parseInt(e.target.value))}
                  className={`w-full rounded-xl px-3 py-2 text-sm ${
                    theme === 'light'
                      ? 'border border-gray-300'
                      : 'border border-gray-600 bg-gray-700'
                  }`}
                >
                  <option value="">Select Starting Node</option>
                  {nodes.map((node) => (
                    <option key={node.id} value={node.id}>
                      {node.value}
                    </option>
                  ))}
                </select>
              </div>

              <button
                disabled={!startNode || nodes.length === 0}
                onClick={() => {
                  resetAlgorithm();
                  if (traversalType === 'BFS') runBFS();
                  else runDFS();
                }}
                className={`w-full text-white px-4 py-2 rounded-xl hover:opacity-90 transition ${
                  !startNode ? 'bg-gray-400' : 'bg-gradient-to-r from-indigo-600 to-blue-600'
                }`}
              >
                {isRunningBFS || isRunningDFS ? 'Running...' : `Run ${traversalType}`}
              </button>
            </div>
            
            {/* Dijkstra */}
            <div className="mb-6">
              <h3 className="font-semibold mb-2">Dijkstra's Shortest Path</h3>
              <div className="grid grid-cols-2 gap-2 mb-3">
                <select
                  value={dijkstraStart}
                  onChange={(e) => setDijkstraStart(parseInt(e.target.value))}
                  className={`rounded-xl px-2 py-2 col-span-1 text-sm ${
                    theme === 'light' ? 'border border-gray-300' : 'border border-gray-600 bg-gray-700'
                  }`}
                >
                  <option value="">From</option>
                  {nodes.map((node) => (
                    <option key={node.id} value={node.id}>
                      {node.value}
                    </option>
                  ))}
                </select>

                <select
                  value={dijkstraTarget}
                  onChange={(e) => setDijkstraTarget(parseInt(e.target.value))}
                  className={`rounded-xl px-2 py-2 col-span-1 text-sm ${
                    theme === 'light' ? 'border border-gray-300' : 'border border-gray-600 bg-gray-700'
                  }`}
                >
                  <option value="">To</option>
                  {nodes.map((node) => (
                    <option key={node.id} value={node.id}>
                      {node.value}
                    </option>
                  ))}
                </select>
              </div>

              <button
                onClick={() => {
                  resetAlgorithm();
                  runDijkstra();
                }}
                disabled={!dijkstraStart || !dijkstraTarget || isRunningDijkstra}
                className={`w-full text-white px-4 py-2 rounded-xl hover:opacity-90 transition ${
                  isRunningDijkstra
                    ? 'bg-gray-500 cursor-not-allowed'
                    : 'bg-gradient-to-r from-indigo-600 to-blue-600'
                }`}
              >
                {isRunningDijkstra ? 'Finding Path...' : 'Find Shortest Path'}
              </button>
            </div>
            
            {/* A* Search */}
            <div className="mb-6">
              <h3 className="font-semibold mb-2">A* Search</h3>
              <div className="flex gap-2 mb-2">
                <select
                  value={heuristicType}
                  onChange={(e) => setHeuristicType(e.target.value)}
                  className={`flex-1 rounded-xl px-2 py-2 text-sm ${
                    theme === 'light' ? 'border border-gray-300' : 'border border-gray-600 bg-gray-700'
                  }`}
                >
                  <option value="euclidean">Euclidean Heuristic</option>
                  <option value="manhattan">Manhattan Heuristic</option>
                </select>
              </div>
              <button
                onClick={() => {
                  resetAlgorithm();
                  runAStar();
                }}
                disabled={!dijkstraStart || !dijkstraTarget || isRunningAStar}
                className={`w-full text-white px-4 py-2 rounded-xl hover:opacity-90 transition ${
                  isRunningAStar
                    ? 'bg-gray-500 cursor-not-allowed'
                    : 'bg-gradient-to-r from-purple-600 to-indigo-600'
                }`}
              >
                {isRunningAStar ? 'Finding Path...' : 'Run A* Search'}
              </button>
            </div>
            
            {/* Prim's MST */}
            <div>
              <h3 className="font-semibold mb-2">Prim's MST</h3>
              <button
                onClick={() => {
                  resetAlgorithm();
                  runPrimMST();
                }}
                disabled={nodes.length === 0 || isRunningPrim}
                className={`w-full text-white px-4 py-2 rounded-xl hover:opacity-90 transition ${
                  isRunningPrim
                    ? 'bg-gray-500 cursor-not-allowed'
                    : 'bg-gradient-to-r from-pink-600 to-rose-600'
                }`}
              >
                {isRunningPrim ? 'Finding MST...' : 'Find Minimum Spanning Tree'}
              </button>
            </div>
          </div>
          
          {/* Saved Graphs */}
          {savedGraphs.length > 0 && (
            <div className={`p-5 rounded-2xl shadow-lg ${theme === 'light' ? 'bg-white' : 'bg-gray-800'}`}>
              <h2 className="text-lg font-bold mb-3">Saved Graphs</h2>
              <div className="space-y-2 max-h-60 overflow-y-auto">
                {savedGraphs.map((graph, index) => (
                  <div 
                    key={index} 
                    className={`p-3 rounded-lg flex justify-between items-center cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 ${
                      theme === 'light' ? 'bg-gray-50' : 'bg-gray-750'
                    }`}
                    onClick={() => loadGraph(graph)}
                  >
                    <div>
                      <div className="font-medium">{graph.name}</div>
                      <div className="text-xs text-gray-500">{graph.nodes.length} nodes, {graph.edges.length} edges</div>
                    </div>
                    <div className="text-xs text-gray-500">
                      {new Date(graph.createdAt).toLocaleDateString()}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Canvas Area */}
        <div className="w-full lg:w-3/4">
          {/* Canvas */}
          <div
            ref={containerRef}
            className="relative"
            onMouseDown={handleMouseDown}
            onMouseUp={handleMouseUp}
            onMouseOver={handleMouseOver}
            onMouseLeave={() => setHoveredElement(null)}
            onContextMenu={handleContextMenu}
          >
            <div
              className={`relative w-full h-[500px] overflow-hidden rounded-2xl shadow-xl ${
                theme === 'light' ? 'bg-gradient-to-br from-blue-50 to-indigo-100' : 'bg-gradient-to-br from-gray-800 to-indigo-900'
              }`}
            >
              <canvas 
                ref={canvasRef} 
                className="w-full h-full cursor-move"
              />
              
              {/* Context Menu */}
              {contextMenu.visible && (
                <div 
                  className="absolute z-10 bg-white dark:bg-gray-800 shadow-2xl rounded-xl py-2 w-48"
                  style={{ left: contextMenu.x, top: contextMenu.y }}
                >
                  {contextMenu.nodeId ? (
                    <>
                      <button 
                        onClick={() => {
                          editNode(contextMenu.nodeId);
                          closeContextMenu();
                        }}
                        className="w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700"
                      >
                        Edit Node
                      </button>
                      <button 
                        onClick={() => {
                          deleteNode(contextMenu.nodeId);
                          closeContextMenu();
                        }}
                        className="w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700 text-red-600 dark:text-red-400"
                      >
                        Delete Node
                      </button>
                    </>
                  ) : contextMenu.edgeId ? (
                    <>
                      <button 
                        onClick={() => {
                          editEdge(contextMenu.edgeId);
                          closeContextMenu();
                        }}
                        className="w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700"
                      >
                        Edit Edge Weight
                      </button>
                      <button 
                        onClick={() => {
                          deleteEdge(contextMenu.edgeId);
                          closeContextMenu();
                        }}
                        className="w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700 text-red-600 dark:text-red-400"
                      >
                        Delete Edge
                      </button>
                    </>
                  ) : (
                    <>
                      <button 
                        onClick={() => {
                          const rect = containerRef.current.getBoundingClientRect();
                          const x = contextMenu.x - rect.left;
                          const y = contextMenu.y - rect.top;
                          addNode(x, y);
                          closeContextMenu();
                        }}
                        className="w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700"
                      >
                        Add Node Here
                      </button>
                      <button 
                        onClick={() => {
                          resetAlgorithm();
                          closeContextMenu();
                        }}
                        className="w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700"
                      >
                        Reset Algorithms
                      </button>
                      <button 
                        onClick={() => {
                          generateRandomGraph();
                          closeContextMenu();
                        }}
                        className="w-full text-left px-4 py-3 hover:bg-gray-100 dark:hover:bg-gray-700"
                      >
                        Generate Random Graph
                      </button>
                    </>
                  )}
                </div>
              )}
            </div>
          </div>
          
          {/* Algorithm Controls */}
          {(isRunningBFS || isRunningDFS || isRunningDijkstra || isRunningPrim || isRunningAStar) && (
            <div className={`mt-4 p-5 rounded-2xl shadow-lg ${theme === 'light' ? 'bg-white' : 'bg-gray-800'}`}>
              <div className="flex flex-wrap items-center justify-between gap-4">
                <div className="flex items-center gap-2">
                  <h3 className="font-semibold">
                    {currentAlgorithm} Execution
                  </h3>
                  <span className="text-xs bg-indigo-100 dark:bg-indigo-900 text-indigo-800 dark:text-indigo-200 px-2 py-1 rounded-full">
                    {algorithmProgress}% Complete
                  </span>
                </div>
                
                <div className="flex items-center gap-2">
                  <button 
                    className="p-2 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                    </svg>
                  </button>
                  
                  <button 
                    onClick={() => setAlgorithmPaused(!algorithmPaused)}
                    className="p-2 rounded-full bg-indigo-600 text-white hover:bg-indigo-700"
                  >
                    {algorithmPaused ? (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clipRule="evenodd" />
                      </svg>
                    ) : (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                      </svg>
                    )}
                  </button>
                  
                  <button 
                    className="p-2 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                    </svg>
                  </button>
                  
                  <button 
                    onClick={resetAlgorithm}
                    className="p-2 rounded-full bg-red-600 text-white hover:bg-red-700"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                  </button>
                </div>
                
                <div className="flex items-center gap-2 text-sm">
                  <span>Speed:</span>
                  <select 
                    value={algorithmSpeed}
                    onChange={(e) => setAlgorithmSpeed(parseInt(e.target.value))}
                    className={`px-2 py-1 rounded-lg ${theme === 'light' ? 'bg-gray-100' : 'bg-gray-700'}`}
                  >
                    <option value="1600">Slow</option>
                    <option value="800">Medium</option>
                    <option value="400">Fast</option>
                  </select>
                </div>
              </div>
              
              <div className="mt-3 w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
                <div 
                  className="bg-gradient-to-r from-indigo-500 to-blue-500 h-2.5 rounded-full transition-all duration-300" 
                  style={{ width: `${algorithmProgress}%` }}
                ></div>
              </div>
            </div>
          )}
          
          {/* Algorithm Results */}
          <div className="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Graph Info Panel */}
            <div className={`p-5 rounded-2xl shadow-lg ${theme === 'light' ? 'bg-white' : 'bg-gray-800'}`}>
              <h2 className="text-lg font-bold mb-4 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
                Graph Information
              </h2>
              
              <div className="grid grid-cols-2 gap-4 mb-4">
                <div className="bg-indigo-50 dark:bg-gray-700 p-4 rounded-xl">
                  <div className="text-sm text-indigo-700 dark:text-indigo-300">Total Nodes</div>
                  <div className="text-2xl font-bold">{nodes.length}</div>
                </div>
                <div className="bg-indigo-50 dark:bg-gray-700 p-4 rounded-xl">
                  <div className="text-sm text-indigo-700 dark:text-indigo-300">Total Edges</div>
                  <div className="text-2xl font-bold">{edges.length}</div>
                </div>
                <div className="bg-indigo-50 dark:bg-gray-700 p-4 rounded-xl">
                  <div className="text-sm text-indigo-700 dark:text-indigo-300">Graph Type</div>
                  <div className="text-xl font-bold capitalize">{graphType}</div>
                </div>
                <div className="bg-indigo-50 dark:bg-gray-700 p-4 rounded-xl">
                  <div className="text-sm text-indigo-700 dark:text-indigo-300">Algorithms</div>
                  <div className="text-xl font-bold">5+</div>
                </div>
              </div>
            </div>
            
            {/* Algorithm Results Panel */}
            <div className={`p-5 rounded-2xl shadow-lg ${theme === 'light' ? 'bg-white' : 'bg-gray-800'}`}>
              <h2 className="text-lg font-bold mb-4 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                </svg>
                Algorithm Results
              </h2>
              
              {bfsResult && traversalType === 'BFS' && (
                <div className="mb-4">
                  <h3 className="font-semibold text-md mb-2 text-indigo-600 dark:text-indigo-400">BFS Results</h3>
                  <div className="mb-2">
                    <span className="font-medium">Traversal Order:</span>
                    <div className="flex flex-wrap gap-1 mt-1">
                      {bfsResult.visitedOrder.map((id, idx) => {
                        const node = nodes.find(n => n.id === id);
                        return (
                          <span key={idx} className={`px-2 py-1 rounded text-sm ${
                            bfsResult.stepIndex > idx
                              ? 'bg-emerald-500 text-white'
                              : bfsResult.stepIndex === idx
                              ? 'bg-pink-500 text-white'
                              : 'bg-gray-200 dark:bg-gray-700'
                          }`}>
                            {node?.value || 'Unknown'}
                          </span>
                        );
                      })}
                    </div>
                  </div>
                </div>
              )}

              {dfsResult && traversalType === 'DFS' && (
                <div className="mb-4">
                  <h3 className="font-semibold text-md mb-2 text-indigo-600 dark:text-indigo-400">DFS Results</h3>
                  <div className="mb-2">
                    <span className="font-medium">Traversal Order:</span>
                    <div className="flex flex-wrap gap-1 mt-1">
                      {dfsResult.visitedOrder.map((id, idx) => {
                        const node = nodes.find(n => n.id === id);
                        return (
                          <span key={idx} className={`px-2 py-1 rounded text-sm ${
                            dfsResult.stepIndex > idx
                              ? 'bg-emerald-500 text-white'
                              : dfsResult.stepIndex === idx
                              ? 'bg-pink-500 text-white'
                              : 'bg-gray-200 dark:bg-gray-700'
                          }`}>
                            {node?.value || 'Unknown'}
                          </span>
                        );
                      })}
                    </div>
                  </div>
                </div>
              )}

              {dijkstraResult && (
                <div className="mb-4">
                  <h3 className="font-semibold text-md mb-2 text-indigo-600 dark:text-indigo-400">Dijkstra Results</h3>
                  <div className="mb-2">
                    <span className="font-medium">Shortest Path:</span>
                    {dijkstraResult.path.length > 0 ? (
                      <div className="flex flex-wrap gap-1 mt-1">
                        {dijkstraResult.path.map((id, idx) => {
                          const node = nodes.find(n => n.id === id);
                          return (
                            <span
                              key={idx}
                              className={`px-2 py-1 rounded text-sm ${
                                idx === 0
                                  ? 'bg-green-500 text-white'
                                  : idx === dijkstraResult.path.length - 1
                                  ? 'bg-red-500 text-white'
                                  : 'bg-orange-500 text-white'
                              }`}
                            >
                              {node?.value || id}
                            </span>
                          );
                        })}
                      </div>
                    ) : (
                      <span className="text-sm">No path found.</span>
                    )}
                  </div>
                  <div className="text-sm">
                    <span className="font-medium">Total Distance:</span> {dijkstraResult.distances[dijkstraTarget]?.toFixed(1) || '-'}
                  </div>
                </div>
              )}

              {primResult && (
                <div className="mb-4">
                  <h3 className="font-semibold text-md mb-2 text-indigo-600 dark:text-indigo-400">Prim's MST Results</h3>
                  <div className="mb-2">
                    <span className="font-medium">MST Edges:</span>
                    <div className="mt-1 space-y-1">
                      {primResult.mstEdges.map((edge, idx) => {
                        const fromNode = nodes.find(n => n.id === edge.from);
                        const toNode = nodes.find(n => n.id === edge.to);
                        return (
                          <div key={idx} className="text-sm bg-purple-50 dark:bg-gray-700 p-2 rounded-lg">
                            {fromNode?.value || '?'} ‚Üî {toNode?.value || '?'} (Weight: {edge.weight.toFixed(1)})
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>
              )}

              {!bfsResult && !dijkstraResult && !primResult && !dfsResult && (
                <div className="text-center py-4 text-gray-500">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 mx-auto text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                  </svg>
                  <p className="mt-2">Run an algorithm to see results here</p>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Footer */}
      <footer className="mt-8 py-6 text-center text-gray-600 dark:text-gray-400">
        <p>Graph Algorithm Visualizer ¬© {new Date().getFullYear()} | Built with React and Framer Motion</p>
        <p className="mt-1 text-sm">Visualize complex algorithms in real-time with this interactive tool</p>
      </footer>
    </div>
  );
}

///App.css
@import "tailwindcss";

///main.jsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

///index.css
@import "tailwindcss";

//index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/Graph.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DSA Graph Visualiser</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

//package.json
{
  "name": "dsa-graph-visualiser",
  "description": "A React-based DSA Graph Visualiser",
  "author": "TOXOTIS",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.7",
    "framer-motion": "^12.15.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "tailwindcss": "^4.1.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "vite": "^6.3.5"
  }
}

//vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
})